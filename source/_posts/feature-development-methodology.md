---
title: Feature Development Methodology
date: 2019-06-14 11:00:50
tags:
---
The various stages in the development of a system component revolves around these central ideas 

## Stage 1 - Conceptualization

We kick things off with a presentation of the idea behind this particular development cycle. For example we say that we need an android application to help sales folks to sell better. While presenting the concept we factor in the business impact this can potentially produce to get a handle on what are the goals of the same, what features will it support, what will it do and what it will not. Subsequent to this we do brainstorming and a few iterations on refining the concept before proceeding. This can take around a week. Another example: we say we say we need a knowledge graph, what are we aiming to do with it ? what is it going to be used for ? How will it be built ? Answers to these questions helps us in finding the real value add it can provide and to what all components present of future. Its critical to document the proceedings of this stage. Usually these tend to be free flowing in the form of word documents, rough drawings of processes, impact analysis on the existing setup, broad category of tools/libraries which can be employed. A lot of times the conceptualization can be around upcoming technologies which gives an R&D feel to the new feature development process. In such cases it is of importance to spend some dev hours to come up with a POC validating the value addition and an approximate methodology of achieving the same.


## Stage 2 - Definition

The definition stage involves creating boundary lines of what the component will actually achieve, example we expect that the KG will provide a queryable knowledge which components like playbook, signals engines, UI elements etc will be able to use and in which manner. While definition we start getting into the specifics and boundaries more, things start to look more concrete. Initially the main artifact during this stage is the UML use-case diagram. The idea at this stage is to provide a complete functional view of the system which can be well understood by all the stakeholders. For example if we are talking about real-time hinting during the conversations as a feature. The use-case drawings will capture various use-cases like having a real-time hinting system at the agent end, giving hints from various sources, having a feedback mechanism to validate the efficacy of cues thrown. Then the UI wireframes can capture the functionality and aesthetics of how this can be achieved visually. Along with a write-up on the use cases and how they relate with the UI wireframes it can be possible to capture the functional requirements of the current sprint.


## Stage 3 - Architecture

The architecting stage will involve thinking what open source components, databases, libraries, services can be used to build from both a stage-wise and a time lapse based manner. Architecturing can involve making choices about the broad spectrum and arranging artifacts to meet the requirements. It is also of extreme importance to also consider all the possibilities that may arise in the  future and to also factor them into the developing architecture. At the end of the architecturing process the deliverables can be ERD/ORMD, Cloud architecture, Sequence, Communication, State Diagrams etc as per the complexity and nature of the problem.

## Stage 4 - Design

At the design stage we start getting into the specifics of the deliverable. Usually design process will involve laying down the exact structure of the code at a class, interface, REST etc.  Various class diagrams can be generated at this stage. At this stage code compactness, reusability, design patterns are taken into account to come up with a lucid design that can be understood and appreciated by a wide community of developers. In addition to the class drawings we also lay down the integration test cases based on the use cases which have been with us since definition. It is a good practice for the class diagram and method definitions within them to have ample documentation to really express what is going to be performed in the design entities. The deliverables from this stage are artifacts like Service , REST diagrams, Integration test cases. 

## Stage 5 - Development

We finally come to the stage where we actually implement the low level artifacts designed during the design stage of the development methodology. Because at this stage the overall structure of the design has been laid out it's a matter of going through the design specs and picking up the right items which best matches the skill set of the developer. In addition to the design in a TDD methodology we also create the test cases of all the class methods at this stage which smoothens the task of the developer to passing the test cases. This test case definition can be a part of the development process or can be done post design and empty skeleton creation. A project manager can also engage with driving the process at this stage to better align the order of deliverables. With a robust architecture, intuitive design and thorough test cases the deliverables at this stage should start to work together.

## Stage 6 - Testing

A part of testing starts before the development phase post the design phase. Post the design phase in a typical TDD we will define test cases for all the interfaces. During the testing phase we think about 2 tiers. The development phase ensured all the unit test cases which are defined at application level have been successfully passed. This can be ensured using a CI tool like Jenkins in tandem with version control (git). In testing we think more about the second tier at the integration level. The integration test cases can be thought of at the user interface level and also at the REST level in a web application scenario. Testing will start with the use case diagrams that have been defined in the previous stages. Along with the use cases (defined during the definition stage) and integration test case (defined during the later parts of the design stage) we have a base for the integration testing. So what happens during the testing stage? The integration test cases are initially run to ensure that all the integration use cases are satisfied. Once we are sure the backend for which the integration cases have been run are operating as expected, (not to mention the unit test cases were passed while collaboration itself); testing shifts to the user interface level testing and initially validating if the design is as per the UI frames created during the definition stage. If there are cross-browser expectations, fluid layout (if specified), exact color etc of the UI constructs. These kind of checks can be performed very smoothly with cloud tools like browserstack. Next the functional QA starts which is again derived directly from the use case diagrams and the common combination of these use-cases. These combinations of test cases are what we call test-suites or integration test cases. They were properly documented at definition stage while we are creating the use cases. QAs simulate these use cases and report back the results. QAs use UI automation tools at this stage to record the simulations carried out by them. These are then integrated into the existing CI workflow to reduce repetitiveness and bring more robustness to incremental building process. Testing can go in tandem with development before the initial release happens, post which the incremental changes are then done as maintenance.

