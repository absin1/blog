---
title: Apache as a Load Balancer
date: 2019-06-24 20:48:01
tags:
---
Let's first install apache server
```
sudo apt-get install apache2
```
First thing we are going to do is enable SSL.
```
sudo a2enmod ssl
```
Let's take a default configuration generated by apache2 and modify it, to create out own virtual host.
```
mv /etc/apache2/sites-available/default-ssl.conf /etc/apache2/sites-available/ind.talentify.in-ssl.conf
```
Time to make SSL chained and validated
```
vi /etc/apache2/sites-available/ind.talentify.in.conf
```
Find these keys and put these values
```
	SSLCertificateFile      /root/vv/talentify.crt
	SSLCertificateKeyFile  /root/vv/my_store.key
	SSLCertificateChainFile /root/vv/Root-R1.crt
```
Now we are done configuring the basic SSL. Let's enable this virtual host.
```
sudo a2ensite ind.talentify.in-ssl
```
Restart and then check the DNS with SSL
```
systemctl reload apache2
```
https://ind.talentify.in should be working now
But what happens if someone tries to open http://ind.talentify.in; because we haven't configured the `000-default.conf`, they will see the default apache2 welcome page. We can change this behaviour to redirection to the secure site.
```
mv 000-default.conf ind.talentify.in.conf
```
Then, let's edit this to enable redirection to https:
```
vi ind.talentify.in.conf
```
And add this line to the end:
```
Redirect permanent / https://ind.talentify.in/
```
And now opening http://ind.talentify.in will take us to https://ind.talentify.in. But now let's put a java application (our backend) behind this apache2.
## Reverse Proxy 
(Official Doc link)[https://httpd.apache.org/docs/2.4/howto/reverse_proxy.html]
(Also good)[https://www.digitalocean.com/community/tutorials/how-to-use-apache-as-a-reverse-proxy-with-mod_proxy-on-ubuntu-16-04]
Let's first enable all the modules required for Load Balancing and Reverse Proxying
```
sudo a2enmod proxy
sudo a2enmod proxy_http
sudo a2enmod proxy_balancer
sudo a2enmod lbmethod_byrequests
sudo a2enmod lbmethod_bytraffic
```
Let's add requisite configuration, you should have these servers up and running
```
vi /etc/apache2/sites-available/ind.talentify.in.conf
```
We define a proxy with balancer and then tell apache to use the same. We also want the second one to take most of the load, so we give a load factor of 3.
```
	<Proxy balancer://backend>
            BalancerMember http://db.talentify.in
            BalancerMember http://ind.talentify.in:8080 loadfactor=3 timeout=1
            ProxySet lbmethod=byrequests
        </Proxy>
        ProxyPass "/"  "balancer://backend/"
        ProxyPassReverse "/"  "balancer://backend/"
```
The only problem in this setup is that if the underlying apache tomcat, which is being reverse proxied by apache2, tries to redirect (302), then the host name which will be used will get drawn from the underlying application and this may cause a number of problems. Inorder to avoid this, add this line before ProxyPass
```
ProxyPreserveHost On
```
[Reference](https://stackoverflow.com/questions/18333252/sending-redirect-in-tomcat-web-application-behind-a-apache-2-proxy-mod-proxy)
## Sticky Sessions
Now, the only problem here is that in a monolithic (JSP kind of) application we won't be able to share sessions. A workaround here can be to offload session persistence in application server to tomcat. This can work in a pure REST microservice environment because there is no contextuality between the subsequent requests. But in a monolithic application this can lead to some problems. 
Which means session persistence in either DB or Memcache or Redis can still bring in irregular experiences when the user logs in for the first time. 
A solution to this can be to have apache2 dictate sticky sessions. What do we make the sessions stick upon? We have JSESSIONID as a candidate however because JSESSIONIDs can get assigned for every request made to the worker, this is unreliable, an efficient solution to this is to let apache2 decide session stickiness using routes.
We will need headers module for this:
```
a2enmod headers
```
Well explained [here](https://httpd.apache.org/docs/2.4/mod/mod_proxy_balancer.html). Taking this into account, our final configuration looks like this:
```
		Header add Set-Cookie "ROUTEID=.%{BALANCER_WORKER_ROUTE}e; path=/" env=BALANCER_ROUTE_CHANGED
                <Proxy balancer://backend>
                    #BalancerMember http://db.talentify.in
                    BalancerMember http://ind.talentify.in:7080 route=1
                    BalancerMember http://ind.talentify.in:8080 route=2
                    ProxySet lbmethod=bytraffic
                    ProxySet stickysession=ROUTEID
                </Proxy>
                ProxyPreserveHost On
                ProxyPass "/"  "balancer://backend/"
                ProxyPassReverse "/"  "balancer://backend/"
```
What's of importance to check here is what if one of the application server fails?
If a node fails then the load balancer automatically switches the incoming load to the other node. Good apache2.
What happens when the failed node comes back up?
Strangely enough what I am seeing so far is that apache2 has to be restarted for the load balance health check to rerun and the first node to be considered as an active candidate.
## Websocket 

Voila!!!

